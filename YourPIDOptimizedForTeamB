#pragma config(Sensor, dgtl1,  leftFrontEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftBackEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightFrontEnc,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightBackEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  bumpSwitch,     sensorTouch)
#pragma config(Motor,  port1,           leftClaw,      tmotorNone, openLoop)
#pragma config(Motor,  port2,           leftFrontD,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftBackD,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftLift3,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightFrontD,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBackD,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLift3,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightClaw,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define PID_INTEGRAL_LIMIT  50
#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)






static float pidRequestedValueLeftBack, pidRequestedValueLeftFront, pidRequestedValueRightBack,  pidRequestedValueRightFront;
int hMotor = 0;//use to strafe
static float Kp = .55;
static float Ki = 0;
static float Kd = 0;
static float leftFrontDriveScale = .55; //Multiply faster motor by this so speed is equal with slower motor
static float leftBackDriveScale = .55;
static float rightFrontDriveScale = 1;
static float rightBackDriveScale = 1;
static bool pidActive = true;

task pidController()
{
	//Initialize variables
	float  pidSensorCurrentValueLeftBack, pidSensorCurrentValueLeftFront, pidSensorCurrentValueRightBack, pidSensorCurrentValueRightFront;
	float  pidErrorLeftBack, pidErrorLeftFront, pidErrorRightBack, pidErrorRightFront;
	float  pidLastErrorLeftBack, pidLastErrorLeftFront, pidLastErrorRightBack, pidLastErrorRightFront;
	float  pidIntegralLeftBack, pidIntegralLeftFront, pidIntegralRightBack, pidIntegralRightFront;
	float  pidDerivativeLeftBack, pidDerivativeLeftFront, pidDerivativeRightBack, pidDerivativeRightFront;
	float  pidDriveLeftBack, pidDriveLeftFront, pidDriveRightBack, pidDriveRightFront;

	//Clear sensor values
	SensorValue[leftBackEnc] = 0;
	SensorValue[leftFrontEnc] = 0;
	SensorValue[rightBackEnc] = 0;
	SensorValue[rightFrontEnc] = 0;

	pidLastErrorLeftBack = 0;
	pidLastErrorLeftFront = 0;
	pidLastErrorRightBack = 0;
	pidLastErrorRightFront = 0;
	
	pidIntegralLeftBack = 0;
	pidIntegralLeftFront = 0;
	pidIntegralRightBack = 0;
	pidIntegralRightFront = 0;

	while(true)
	{
		antiGrav(); //Keeps lift stationary
		hDrive(hMotor);
		//If the pid is set to active
		if(pidActive)
		{
			//Calculate proportional portion
			pidSensorCurrentValueLeftBack = SensorValue[leftBackEnc];
			pidSensorCurrentValueLeftFront = SensorValue[leftFrontEnc];
			pidSensorCurrentValueRightBack = SensorValue[rightBackEnc];
			pidSensorCurrentValueRightFront = SensorValue[rightFrontEnc];

			pidErrorLeftBack = pidSensorCurrentValueLeftBack - pidRequestedValueLeftBack;
			pidErrorLeftFront = pidSensorCurrentValueLeftFront - pidRequestedValueLeftFront;
			pidErrorRightBack = pidSensorCurrentValueRightBack - pidRequestedValueRightBack;			
			pidErrorRightFront = pidSensorCurrentValueRightFront - pidRequestedValueRightFront;
			// Calculate integral portion
			// Add the error to the integral if it is outside the controllable range of values
			if(abs(pidErrorLeftBack) < PID_INTEGRAL_LIMIT)
				pidIntegralLeftBack = pidIntegralLeftBack + pidErrorLeftBack;
			else
				pidIntegralLeftBack = 0;

			if(abs(pidErrorLeftFront) < PID_INTEGRAL_LIMIT)
				pidIntegralLeftFront = pidIntegralLeftFront + pidErrorLeftFront;
			else
				pidIntegralLeftFront = 0;

			if(abs(pidErrorRightBack) < PID_INTEGRAL_LIMIT)
				pidIntegralRightBack = pidIntegralRightBack + pidErrorRightBack;
			else
				pidIntegralRightBack = 0;

			if(abs(pidErrorRightFront) < PID_INTEGRAL_LIMIT)
				pidIntegralRightFront = pidIntegralRightFront + pidErrorRightFront;
			else
				pidIntegralRightFront= 0;

			// Calculate derivitave portion
			pidDerivativeLeftBack = pidErrorLeftBack - pidLastErrorLeftBack;
			pidDerivativeLeftFront = pidErrorLeftFront - pidLastErrorLeftFront;
			pidDerivativeRightBack = pidErrorRightBack - pidLastErrorRightBack;
			pidDerivativeRightFront = pidErrorRightFront - pidLastErrorRightFront;


			pidLastErrorLeftBack = pidErrorLeftBack;
			pidLastErrorLeftFront = pidErrorLeftFront;
			pidLastErrorRightBack = pidErrorRightBack;
			pidLastErrorRightFront = pidErrorRightFront;


			// calculate drive
			pidDriveLeftBack = (Kp * pidErrorLeftBack) + (Ki * pidIntegralLeftBack) + (Kd * pidDerivativeLeftBack);
			pidDriveLeftFront = (Kp * pidErrorLeftFront) + (Ki * pidIntegralLeftFront) + (Kd * pidDerivativeLeftFront);			
			pidDriveRightBack = (Kp * pidErrorRightBack) + (Ki * pidIntegralRightBack) + (Kd * pidDerivativeRightBack);
			pidDriveRightFront = (Kp * pidErrorRightFront) + (Ki * pidIntegralRightFront) + (Kd * pidDerivativeRightFront);

			// limit drive
			if( pidDriveLeftBack > PID_DRIVE_MAX )
				pidDriveLeftBack = PID_DRIVE_MAX;
			if( pidDriveLeftBack < PID_DRIVE_MIN )
				pidDriveLeftBack = PID_DRIVE_MIN;

			if( pidDriveLeftFront > PID_DRIVE_MAX )
				pidDriveLeftFront = PID_DRIVE_MAX;
			if( pidDriveLeftFront < PID_DRIVE_MIN )
				pidDriveLeftFront = PID_DRIVE_MIN;

				
				
			if( pidDriveRightBack > PID_DRIVE_MAX )
				pidDriveRightBack = PID_DRIVE_MAX;
			if( pidDriveRightBack < PID_DRIVE_MIN )
				pidDriveRightBack = PID_DRIVE_MIN;

			if( pidDriveRightFront > PID_DRIVE_MAX )
				pidDriveRightFront = PID_DRIVE_MAX;
			if( pidDriveRightFront < PID_DRIVE_MIN )
				pidDriveRightFront = PID_DRIVE_MIN;

			// DRIVE BOI DRIVE
			motor[leftBackD] = (int) ((float)pidDriveLeftBack * (-1.0)*leftFrontDriveScale);
			motor[leftFrontD] = (int)((float)pidDriveLeftFront * (-1.0)*leftFrontDriveScale);
			motor[rightBackD] = (int)((float)pidDriveRightBack * rightBackDriveScale);
			motor[rightFrontD] = (int)((float)pidDriveRightFront * rightFrontDriveScale);
		}
		else // delete the emails, i mean variables
		{
			pidSensorCurrentValueLeftBack = 0;
			pidSensorCurrentValueLeftFront = 0;
			pidSensorCurrentValueRightBack = 0;
			pidSensorCurrentValueRightFront = 0;
			
			pidErrorLeftBack = 0;
			pidErrorLeftFront = 0;
			pidErrorRightBack = 0;
			pidErrorRightFront = 0;
			
			pidLastErrorLeftBack = 0;
			pidLastErrorLeftFront = 0;
			pidLastErrorRightBack = 0;
			pidLastErrorRightFront = 0;
			
			pidIntegralLeftBack = 0;
			pidIntegralLeftFront = 0;
			pidIntegralRightBack = 0;
			pidIntegralRightFront = 0;
			
			pidDerivativeLeftBack = 0;
			pidDerivativeLeftFront = 0;
			pidIntegralRightBack = 0;
			pidIntegralRightFront = 0;
			
			pidDriveLeftBack = 0;
			pidDriveLeftFront = 0;
			pidDriveRightBack = 0;
			pidDriveRightFront = 0;
						
			motor[leftBackD] = 0;
			motor[leftFrontD] = 0;
			motor[rightBackD] = 0;
			motor[rightFrontD] = 0;
		}

	}
}


task main
{
	
}
