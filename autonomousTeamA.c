#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftBottomLift, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rightBottomLift, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftClaw,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightDrive,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightClaw,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rightTopLift,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftTopLift,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightH,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int oldRight = 0;
int oldLeft = 0;

int distanceToAngles(int distance) //15.71 inch diameter
{
	return (int)((distance/15.7) * 360);
}

void drive(int distance)
{
	int angles = distanceToAngles(distance);
	 	writeDebugStreamLine("%d",angles);
	while((SensorValue[rightEnc] + SensorValue[leftEnc] - oldRight - oldLeft) < (angles))
	{
		if(distance > 0)
		{
			motor[rightDrive] = 127;
			motor[leftDrive] = 127;
		}
		else
		{
			motor[rightDrive] = -127;
			motor[leftDrive] = -127;

		}

	}

	oldRight = SensorValue[rightEnc];
	oldLeft = SensorValue[leftEnc];
}


void strafe(int distance) //Negative for left, positive for right
{

}

void turn(int angles) //Negative for counerclockwise, positive for clockwise
{

}


task main()
{
	SensorValue[rightEnc] = 0;
	SensorValue[leftEnc] = 0;

		drive(100);

}
